#!/usr/bin/env python3

from dotenv import load_dotenv, find_dotenv
load_dotenv(find_dotenv())

import mimetypes
mimetypes.init()

import os
import sys
import subprocess
import glob
import argparse
import shutil
import json
from github3 import login
from munch import Munch
import packaging.version
from urllib.request import urlopen
from urllib.request import urlretrieve
import xml.etree.ElementTree as ET
import re
import tarfile
import configparser
import textwrap
import zipfile
from termcolor import colored
import toml

parser = argparse.ArgumentParser()
parser.add_argument('--bump', action='store_true')
parser.add_argument('--upgrade', action='store_true')
parser.add_argument('--force', action='store_true')
parser.add_argument('--dry-run', action='store_true')
parser.add_argument('--test', action='store_true')
parser.add_argument('--rdepends', action='store_true')
args = parser.parse_args()

with open(os.path.join(os.path.dirname(__file__), 'config.toml')) as f:
  config = toml.load(f, _dict=Munch)

COLORS = Munch(
  repo='yellow',
  package='cyan',
  shell='magenta',
  progress='blue',
  result='green',
  error='red',
)

def run(cmd):
  print(colored(f'{cmd}', COLORS.shell))
  if os.system(cmd) != 0:
    print(colored(f'{cmd} exited with an error'), COLORS.error)
    sys.exit(1)

def rm_rf(*paths):
  for path in paths:
    if os.path.isdir(path): shutil.rmtree(path)
    if os.path.isfile(path): os.remove(path)

class Package:
  def __init__(self, package):
    package = Munch({**config.package[package.package], **package})
    # find current version
    feed = f'https://github.com/{package.repo}/releases.atom'
    response = urlopen(feed).read()
    if type(response) is bytes: response = response.decode("utf-8")
    root = ET.fromstring(response)
    version = root.find('{http://www.w3.org/2005/Atom}entry/{http://www.w3.org/2005/Atom}id').text
    self.base_version = version.split('/')[-1]

    if args.bump or args.upgrade:
      if not 'version' in config.package[package.package]:
        self.bump = 0
        config.package[package.package].pop('bump', None)
        print(f'No version information for {package.package}, setting to {self.base_version}')
      elif packaging.version.parse(config.package[package.package].version.replace('m', '.')) < packaging.version.parse(self.base_version.replace('m', '.')):
        config.package[package.package].pop('bump', None)
        self.bump = 0
        print(f'Upgrading {package.package} to {self.base_version}')
      elif args.bump and not 'bump' in config.package[package.package]:
        config.package[package.package].bump = 1
        print(f'Bumping {package.package} to {config.package[package.package].bump}')
      elif args.bump:
        config.package[package.package].bump += 1
        print(f'Bumping {package.package} to {config.package[package.package].bump}')
      config.package[package.package].version = self.base_version

    if not 'version' in config.package[package.package]:
      print(f'No version information for {package.package}')
      sys.exit(1)
    if config.package[package.package].version != self.base_version:
      print(f'Building {config.package[package.package].version}, but {self.base_version} is available')
      sys.exit(1)

    self.version = config.package[package.package].version
    self.bump = 0
    if 'bump' in config.package[package.package]:
      self.bump = config.package[package.package].bump
      self.version += f'-{self.bump}'

    self.binary_url = package.download
    self.package = package.package
    self.name = package.name
    self.dependencies = ', '.join(package.dependencies)
    self.global_menu = package.global_menu

    self.public = Munch.fromDict({arch: None for arch in package.archs})

    for asset in package.assets:
      m = re.match(f'{self.package}_([0-9m.]+)(?:-([0-9]+))?_([a-z0-9]+)\\.deb$', asset)
      if m:
        version = m.group(1)

        bump = m.group(2)
        bump = int(bump) if bump else 0

        arch = m.group(3)
        assert arch in package.archs, f'{arch} not in {ARCHS}'
        assert arch not in self.public or self.public[arch] is None, f'{asset} already known as {self.public[arch]}'

        self.public[arch] = Munch(base_version=version, bump=bump)

    self.needs_update = args.force
    for arch in package.archs:
      if not self.public[arch]:
        self.needs_update = True
        break
      if self.public[arch].base_version != self.base_version:
        self.needs_update = True
        break
      if self.public[arch].bump != self.bump:
        self.needs_update = True
        break

  def deb(self, arch):
    return f'{self.package}_{self.version}_{arch}.deb'

  def build(self, arch):
    deb = self.deb(arch)
    print(colored(f'\n## building {deb}', COLORS.package))

    rm_rf('build', 'client.tar.bz2', deb)
    os.makedirs(f'build/usr/lib/{self.package}/distribution')
    os.makedirs('build/usr/share/applications')
    os.makedirs('build/DEBIAN')
    url = self.binary_url.format(arch={'amd64': 'x86_64', 'i386': 'i686'}[arch], version=self.base_version)
    print(colored(f'downloading {url}', COLORS.progress))
    urlretrieve(url, 'client.tar.bz2')

    tar = tarfile.open('client.tar.bz2')
    members = [member for member in tar.getmembers() if member.isreg()] # skip if the TarInfo is not files
    for member in tar.getmembers():
      if not member.isreg(): continue
      member.name = re.sub(r'^.+?\/', '', member.name) # strip leading directory

      if member.name in ['active-update.xml', 'precomplete', 'removed-files', 'updates', 'updates.xml']:
        continue

      tar.extract(member, f'build/usr/lib/{self.package}')
    tar.close()

    self.patch_global_menu(f'build/usr/lib/{self.package}')

    with open(f'build/usr/lib/{self.package}/distribution/policies.json', 'w') as f:
      f.write(json.dumps({ "policies": { "DisableAppUpdate": True } }))

    desktop = configparser.RawConfigParser()
    desktop.add_section('Desktop Entry')
    desktop.optionxform=str
    desktop.set('Desktop Entry', 'Name', self.name)
    if self.global_menu:
      desktop.set('Desktop Entry', 'Comment', 'Open-source reference manager (global menu support)')
    else:
      desktop.set('Desktop Entry', 'Comment', 'Open-source reference manager')
    desktop.set('Desktop Entry', 'Exec', f'/usr/lib/{self.package}/{self.package} --url %u')
    desktop.set('Desktop Entry', 'Icon', f'/usr/lib/{self.package}/chrome/icons/default/default48.png')
    desktop.set('Desktop Entry', 'Type', 'Application')
    desktop.set('Desktop Entry', 'StartupNotify', 'true')
    desktop.set('Desktop Entry', 'MimeType', ';'.join([
      'x-scheme-handler/zotero',

      # Research Information Systems Document
      'ris',
      'application/x-research-info-systems',
      'application/x-endnote-refer',
      'text/x-research-info-systems',
      'text/application/x-research-info-systems',
      'text/ris',

      # ISI Common Export Format Document
      'ciw',
      'isi',
      'application/x-inst-for-Scientific-info',

      # Metadata Object Description Schema Document
      'mods',
      'application/mods+xml',

      # Resource Description Framework Document
      'rdf',
      'application/rdf+xml',

      # BibTeX Document
      'bib',
      'bibtex',
      'application/x-bibtex',
      'text/x-bibtex',

      # MARC Record
      'mrc',
      'marc',
      'application/marc',

      # CSL Citation Style
      'csl',
      'vnd.citationstyles.style+xml',
    ]))

    with open(f'build/usr/share/applications/{self.package}.desktop', 'w') as f:
      desktop.write(f, space_around_delimiters=False)

    with open('build/DEBIAN/control', 'w') as f:
      print(f'Package: {self.package}', file=f)
      print(f'Architecture: {arch}', file=f)
      print(f'Depends: {self.dependencies}'.strip(), file=f)
      print(f'Maintainer: {config.build.maintainer}', file=f)
      print('Section: Science', file=f)
      print('Priority: optional', file=f)
      print(f'Version: {self.version}', file=f)
      print(f'Description: {self.name} is a free, easy-to-use tool to help you collect, organize, cite, and share research', file=f)

    run(f'fakeroot dpkg-deb --build -Zgzip build repo/{deb}')
    run(f'dpkg-sig -k {config.build.gpgkey} --sign builder repo/{deb}')

  def patch_global_menu(self, installdir):
    if not self.global_menu: return
    print(colored('patching for global menu', COLORS.progress))

    url = urlopen('https://github.com/ripefig/Firefox-ESR-52-Global-Menu/releases/latest').geturl().replace('/tag/', '/download/') + '/libxul.so'
    urlretrieve(url, f'{installdir}/libxul.so')

    jar = os.path.join(installdir, self.package + '.jar')
    jar_gm = os.path.join(self.package + '.jar')
    with zipfile.ZipFile(jar, 'r') as zj:
      with zipfile.ZipFile(jar_gm, 'w') as zjgm:
        for item in zj.infolist():
          data = zj.read(item.filename)
          if item.filename == 'chrome/skin/default/zotero/zotero.css':
            data = data.decode('utf-8') + textwrap.dedent('''
              window[shellshowingmenubar="true"] menubar {
                display: none !important;
              }

              window[shellshowingmenubar="true"]
              toolbar[type="menubar"]:not([customizing="true"]) {
                min-height: 0 !important;
                border: 0 !important;
              }
            ''')
          zjgm.writestr(item, data)
    os.remove(jar)
    os.rename(jar_gm, jar)

# let's get it started

if args.rdepends:
  rdepends = set([])
  for pkg in config.package.keys():
    for dep in config.package[pkg].dependencies:
      rdepends.add(dep)
  run('apt-cache rdepends ' + ' '.join(rdepends))
  sys.exit(0)

gh = login(token=os.getenv('GITHUB_TOKEN'))
repo = gh.repository(*config.build.repo.split('/'))

for release_name in config.release.keys():
  global_menu = release_name == 'global-menu'
  print(colored(f'\n\n# Building {release_name}', COLORS.repo))

  if args.test:
    release = repo.release_from_tag(release_name + '-test')
  else:
    release = repo.release_from_tag(release_name)

  assets = release.assets()

  packages = Munch(
    zotero = Package(Munch(
      package='zotero',
      assets=[asset.name for asset in assets],
      archs=config.release[release_name].archs,
      global_menu=global_menu
    )),
    jurism = Package(Munch(
      package='jurism',
      assets=[asset.name for asset in assets],
      archs=config.release[release_name].archs,
      global_menu=global_menu
    ))
  )
  if args.bump or args.upgrade:
    break

  if not packages.zotero.needs_update and not packages.jurism.needs_update:
    print(colored('nothing to do', COLORS.result))
    continue

  rm_rf('repo')
  os.mkdir('repo')

  for package in config.package.keys():
    for arch in config.release[release_name].archs:
      packages[package].build(arch)

  print(colored(f'\n## publishing {release_name}', COLORS.package))
  run(f'gpg --armor --export {config.build.gpgkey} > repo/deb.gpg.key')
  run(f'cd repo && apt-ftparchive packages . > Packages')
  run(f'bzip2 -kf repo/Packages')
  run(f'cd repo && apt-ftparchive release . > Release')
  run(f'gpg --yes -abs -u {config.build.gpgkey} -o repo/Release.gpg --digest-algo sha256 repo/Release')
  run(f'gpg --yes -abs -u {config.build.gpgkey} --clearsign -o repo/InRelease --digest-algo sha256 repo/Release')

  with open('repo/install.sh', 'w') as f:
    print(textwrap.dedent(f'''
      if [ -x "$(command -v curl)" ]; then
        curl --silent -L https://github.com/{config.build.repo}/releases/download/{release_name}/deb.gpg.key | sudo apt-key add -
      elif [ -x "$(command -v wget)" ]; then
        wget -qO- https://github.com/{config.build.repo}/releases/download/{release_name}/deb.gpg.key | sudo apt-key add -
      else
        echo "Error: need wget or curl installed." >&2
        exit 1
      fi

      cat << EOF | sudo tee /etc/apt/sources.list.d/zotero.list
      deb https://github.com/{config.build.repo}/releases/download/{release_name}/ ./
      EOF
    '''), file=f)

  if not args.dry_run:
    for asset in assets:
      asset.delete()

    for asset in sorted(glob.glob('repo/*')):
      content_type = mimetypes.guess_type(asset)[0] or 'application/octet-stream'
      print(colored(f'Uploading {asset} ({content_type})', COLORS.progress))
      with open(asset, 'rb') as f:
        release.upload_asset(
          asset=f,
          name=os.path.basename(asset),
          content_type=content_type
        )

if args.bump or args.upgrade:
  with open(os.path.join(os.path.dirname(__file__), 'config.toml'), 'w') as f:
    toml.dump(config, f)
