#!/usr/bin/env python3

from dotenv import load_dotenv, find_dotenv
load_dotenv(find_dotenv())

import os
import sys
import subprocess
import glob
import argparse
import shutil
import json
from github3 import login
from munch import Munch
import packaging.version
from urllib.request import urlopen
from urllib.request import urlretrieve
import xml.etree.ElementTree as ET
import re
import tarfile
import configparser
import textwrap

parser = argparse.ArgumentParser()
parser.add_argument('--bump', action='store_true')
parser.add_argument('--force', action='store_true')
args = parser.parse_args()

ARCHS = ['i386', 'amd64']
PACKAGES = ['zotero', 'jurism']
MAINTAINER = 'emiliano.heyns@iris-advies.com'
GPGKEY = 'dpkg'

def run(cmd):
  print("\n" + cmd)
  if subprocess.call(cmd, shell=True) != 0:
    print(f'{cmd} exited with an error')
    sys.exit(1)

def rm_rf(*paths):
  for path in paths:
    if os.path.isdir(path): shutil.rmtree(path)
    if os.path.isfile(path): os.remove(path)

class Package:
  def __init__(self, repo, binary_url, package, assets, name):
    # find current version
    feed = f'https://github.com/{repo}/releases.atom'
    response = urlopen(feed).read()
    if type(response) is bytes: response = response.decode("utf-8")
    root = ET.fromstring(response)
    version = root.find('{http://www.w3.org/2005/Atom}entry/{http://www.w3.org/2005/Atom}id').text
    self.version = version.split('/')[-1]
    
    self.binary_url = binary_url
    self.package = package
    self.name = name

    self.public = Munch.fromDict({arch: None for arch in ARCHS})

    for asset in assets:
      m = re.match(f'{self.package}_([0-9m.]+)(?:-([0-9]+))?_([a-z0-9]+)\\.deb$', asset)
      if m:
        version = m.group(1)

        bump = m.group(2)
        bump = int(bump) if bump else 0

        arch = m.group(3)
        assert arch in ARCHS
        assert arch not in self.public or self.public[arch] is None, f'{asset} already known as {self.public[arch]}'

        self.public[arch] = Munch(version=version, bump=bump)

    self.needs_update = False
    if args.bump or args.force:
      self.needs_update = True
    for arch in ARCHS:
      if not self.public[arch]:
        self.needs_update = True
        break
      if packaging.version.parse(self.public[arch].version.replace('m', '.')) < packaging.version.parse(self.version.replace('m', '.')):
        self.needs_update = True

  def deb(self, arch):
    if not arch in self.public: # first build for version, don't bump
      bump = ''
    elif args.bump:
      bump = f'-{self.public[arch].bump + 1}'
    elif self.public[arch].bump > 0:
      bump = f'-{self.public[arch].bump}'
    else:
      bump = ''
    return f'{self.package}_{self.version}{bump}_{arch}.deb'

  def build(self, arch):
    deb = self.deb(arch)
    print(f'building {deb}')

    rm_rf('build', 'client.tar.bz2', deb)
    os.makedirs(f'build/usr/lib/{self.package}/distribution')
    os.makedirs('build/usr/share/applications')
    os.makedirs('build/DEBIAN')
    url = self.binary_url.format(arch={'amd64': 'x86_64', 'i386': 'i686'}[arch], version=self.version)
    print(f'downloading {url}')
    urlretrieve(url, 'client.tar.bz2')

    tar = tarfile.open('client.tar.bz2')
    members = [member for member in tar.getmembers() if member.isreg()] # skip if the TarInfo is not files
    for member in tar.getmembers():
      if not member.isreg(): continue
      member.name = re.sub(r'^.+?\/', '', member.name) # strip leading directory

      if member.name in ['active-update.xml', 'precomplete', 'removed-files', 'updates', 'updates.xml']:
        continue

      tar.extract(member, f'build/usr/lib/{self.package}')
    tar.close()

    with open(f'build/usr/lib/{self.package}/distribution/policies.json', 'w') as f:
      f.write(json.dumps({ "policies": { "DisableAppUpdate": True } }))

    desktop = configparser.RawConfigParser()
    desktop.add_section('Desktop Entry')
    desktop.set('Desktop Entry', 'Name', self.name)
    desktop.set('Desktop Entry', 'Comment', 'Open-source reference manager')
    desktop.set('Desktop Entry', 'Exec', f'/usr/lib/{self.package}/{self.package} --url %u')
    desktop.set('Desktop Entry', 'Icon', f'/usr/lib/{self.package}/chrome/icons/default/default48.png')
    desktop.set('Desktop Entry', 'Type', 'Application')
    desktop.set('Desktop Entry', 'StartupNotify', 'true')
    desktop.set('Desktop Entry', 'MimeType', 'x-scheme-handler/zotero')
    with open(f'build/usr/share/applications/{self.package}.desktop', 'w') as f:
      desktop.write(f, space_around_delimiters=False)

    with open('build/DEBIAN/control', 'w') as f:
      print(f'Package: {self.package}', file=f)
      print(f'Architecture: {arch}', file=f)
      print('Depends: libnss3-dev', file=f)
      print(f'Maintainer: {MAINTAINER}', file=f)
      print('Section: Science', file=f)
      print('Priority: optional', file=f)
      print(f'Version: {self.version}', file=f)
      print(f'Description: {self.name} is a free, easy-to-use tool to help you collect, organize, cite, and share research', file=f)

    run(f'dpkg-deb --root-owner-group --build -Zgzip build repo/{deb}')
    run(f'dpkg-sig -k {GPGKEY} --sign builder repo/{deb}')

# let's get it started
gh = login(token=os.getenv('GITHUB_TOKEN'))
repo = repo = gh.repository('retorquere', 'zotero-deb')
release = repo.release_from_tag('apt-get')
assets = release.assets()

packages = Munch(
  zotero = Package(
    repo='zotero/zotero',
    package='zotero',
    name='Zotero',
    binary_url='https://www.zotero.org/download/client/dl?channel=release&platform=linux-{arch}&version={version}',
    assets=[asset.name for asset in assets]
  ),
  jurism = Package(
    repo='Juris-M/zotero',
    package='jurism',
    name='Juris-M',
    binary_url='https://github.com/Juris-M/assets/releases/download/client%2Frelease%2F{version}/Jurism-{version}_linux-{arch}.tar.bz2',
    assets=[asset.name for asset in assets]
  )
)

if not packages.zotero.needs_update and not packages.jurism.needs_update:
  print('nothing to do')
  sys.exit(0)

rm_rf('repo')
os.mkdir('repo')

for asset in assets:
  if asset.name.startswith('zotero') and packages.zotero.needs_update:
    #asset.delete()
    continue
  if asset.name.startswith('jurism') and packages.jurism.needs_update:
    #asset.delete()
    continue
  print(f'Downloading {asset.name}')
  with open(os.path.join('repo', asset.name), 'wb') as f:
    asset.download(f)

for package in PACKAGES:
  if not packages[package].needs_update: continue
  for arch in ARCHS:
    packages[package].build(arch)

run(f'gpg --armor --export {GPGKEY} > repo/deb.gpg.key')
run(f'cd repo && apt-ftparchive packages . > Packages')
run(f'bzip2 -kf repo/Packages')
run(f'cd repo && apt-ftparchive release . > Release')
run(f'gpg --yes -abs -u {GPGKEY} -o repo/Release.gpg --digest-algo sha256 repo/Release')
run(f'gpg --yes -abs -u {GPGKEY} --clearsign -o repo/InRelease --digest-algo sha256 repo/Release')

with open('repo/install.sh', 'w') as f:
  print(textwrap.dedent(f'''
    if [ -x "$(command -v curl)" ]; then
      curl --silent -L https://github.com/retorquere/zotero-deb/releases/download/apt-get/deb.gpg.key | sudo apt-key add -
    elif [ -x "$(command -v wget)" ]; then
      wget -qO- https://github.com/retorquere/zotero-deb/releases/download/apt-get/deb.gpg.key | sudo apt-key add -
    else
      echo "Error: need wget or curl installed." >&2
      exit 1
    fi

    cat << EOF | sudo tee /etc/apt/sources.list.d/zotero.list
    deb https://github.com/retorquere/zotero-deb/releases/download/apt-get/ ./
    EOF
  '''), file=f)

#if action == 'stash':
#  for asset in glob.glob('xpi/*.xpi') + generated:
#    print(f'Uploading {asset}')
#    with open(asset, 'rb') as f:
#      release.upload_asset(
#        asset=f,
#        name=name_prefix + asset.replace('/', '-'),
#        label=label_prefix + asset,
#        content_type=('application/x-xpinstall' if asset.endswith('.xpi') else 'application/json')
#      )
